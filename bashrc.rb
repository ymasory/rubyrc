# A bash resources file..
class BashRC

  def initialize
    @cmds = [
      "# bash resources file, auto-generated by #{__FILE__}",
      "# DO NOT MODIFY, your changes will be lost"
    ]
    @homedir = File.expand_path '~'
    @Colon = ':'
    @SingleQuote = "'"
    @DoubleQuote = '"'
  end

  #---- BASH FUNCTIONS ----#

  def make_var k, v, export
    if v.nil?
      puts "skipping #{k} which is mapped to nil"
    else
      qv = quote v
      if qv.nil?
        puts "skipping #{k} #{v} declare due to quoting problem"
      else
        cmd = "declare#{if export then " -x" else "" end} #{k}=#{qv}"
        add_raw cmd
      end
    end
  end
  private:make_var

  # bash: <tt>declare k=v</tt>.
  def declare(k, v) make_var(k, v, false) end

  # bash: <tt>declare -x k=v</tt>.
  def export(k, v) make_var(k, v, true) end

  # bash: <tt>alias k=v</tt>.
  def alias k, v
    qv = quote v
    if qv.nil?
      puts "skipping #{k} #{v} alias due to quoting problem"
    else
      cmd = "alias #{k}=#{qv}"
      add_raw cmd
    end
  end

  # bash: <tt>function() {}</tt>.
  def declfunc k, fun
    decl =
      <<-FUN.gsub(/^\s{6}/, '').strip
      function #{k} {
        echo 'howdy #{k}!'
      }
     FUN
    add_raw decl
  end

  # bash: <tt>source fname</tt>.
  def source fname
    qf = quote fname
    if qf.nil? then puts "skipping source #{fname} due to quoting problem"
    else add_raw "source #{qf}"
    end
  end

  # bash: <tt>shopt -s pref</tt>
  def shopt_set pref
    shopt_common pref, "-s"
  end

  # bash: <tt>shopt -u pref</tt>
  def shopt_unset pref
    shopt_common pref, "-u"
  end

  def shopt_common pref, flag
    qp = quote pref
    if qp.nil? then puts "skipping shopt #{qp} due to quoting problem"
    else add_raw "shopt #{flag} #{qp}"
    end
  end
  private :shopt_common

  #---- CONVENIENCE METHOD ----#

  # Linux +LS_COLORS+ only, not BSD +LSCOLORS+
  def ls_colors ext_map, type_map
    ext_lst =
      ext_map.keys.map { |k|
        globs = ext_map[k]
        globs.map { |g| "*.#{g}=#{k}" }
      }
    type_lst =
      type_map.keys.map { |k|
        color = type_map[k]
        "#{k}=#{color}"
      }
    desc = (type_lst + ext_lst).join ':'
    export 'LS_COLORS', desc
  end

  # +declare+ but with +k+ considered a relative path from the user's home, and
  # automatically expanded accordingly.
  def declare_home(k, v) declare(k, homify(v)) end

  # +export+ but with +k+ considered a relative path from the user's home, and
  # automatically expanded accordingly.
  def export_home(k, v) export(k, homify(v)) end

  def append_to_path(fname) add_to_path fname, true end
  def prepend_to_path(fname) add_to_path fname, false end

  def add_to_path fname, append
    varname = 'PATH'
    var = "${#{varname}}"
    declare = 'declare -x'
    new_path = append ? "#{var}:#{fname}" : "#{fname}:#{var}"
    decl =
      <<-HERE.gsub(/^\s{6}/, '').strip
      if [ ! -z "#{var}" ]
        then #{declare} #{varname}="#{new_path}"
      else
        #{declare} #{varname}=#{quote(fname)}
      fi
      HERE
    add_raw(decl)
  end
  private :add_to_path

  #---- METHODS FOR INTERACTION WITH BASH ----#

  # Write the current state of the bash resources to the provided +path+.
  def write path
    File.open(path, 'w') do |io|
      io.print serialize
    end
  end

  #---- UTILITIES ----#

  # Create an absolute path consisting of the home directory joined with the
  # provided relative filename.
  def homify f = ''
    if f.length == 0 then @homedir
    else "#{@homedir}/#{f}" end
  end

  # Alias for +serialize+.
  def to_s() serialize end

  def quote s
    q = choose_quote s
    if q.nil? then nil
    else "#{q}#{s}#{q}"
    end
  end
  private :quote

  def choose_quote s
    hasSingle = s.include? @SingleQuote
    hasDouble = s.include? @DoubleQuote
    if not hasSingle and not hasDouble then @SingleQuote
    elsif hasSingle and not hasDouble then @DoubleQuote
    elsif not hasSingle and hasDouble then @SingleQuote
    else nil
    end
  end
  private :choose_quote


  #---- METHODS FOR MANAGING STORED BASH COMMANDS ----#

  # Add straight bash as a resource, to be written without
  # modification. All other resource-adding methods go through here so checking
  # can be done.
  def add_raw cmd
    @cmds << cmd
  end
  #private :add_raw

  # The file contents, exactly as they will be written if +write+ is called
  # now.
  def serialize
    lf = "\n"
    (@cmds.join lf) + lf
  end
  private :serialize
end

class PromptUtil
  def self.esc(str) "\\[#{str}\\]" end
end

class Prompt

  @@Plain, @@Bold, @@Underline, @@Intense =
    ['plain', 'bold', 'underline', 'intense']

  def self.make_prompt format, prompt_core
    reset = "#{PromptUtil.esc '\e[0m'} "
    format_repr = PromptUtil.esc self.parse_format(format)
    "#{format_repr}#{prompt_core}#{reset}"
  end

  def self.add_title prompt, title
    window_title_pwd_suffix = "\\[\\e]0;#{title}\\a\\]"
    prompt + window_title_pwd_suffix
  end

  #---- PRIVATE ----#
  private

  def self.parse_format format
    parts = format.split
    color = parts.last
    style = if parts.length == 1 then @@Plain else parts.first end
    if    color == 'black'  then wrap(0, style)
    elsif color == 'red'    then wrap(1, style)
    elsif color == 'green'  then wrap(2, style)
    elsif color == 'yellow' then wrap(3, style)
    elsif color == 'blue'   then wrap(4, style)
    elsif color == 'purple' then wrap(5, style)
    elsif color == 'cyan'   then wrap(6, style)
    elsif color == 'white'  then wrap(7, style)
    else raise "unknown color #{color}"
    end
  end

  def self.wrap color_code, style
    code1, code2 =
      if    style == @@Plain     then ['0', '3']
      elsif style == @@Bold      then ['1', '3']
      elsif style == @@Underline then ['4', '3']
      elsif style == @@Intense   then ['0', '9']
      elsif style == :boldint    then ['1', '9']
      elsif style == :back       then ['0', '9']
      elsif style == :backint    then [nil, nil] #not following simple pattern
      else raise "unknown style #{style}"
      end
    "\\e[#{code1};#{code2}#{color_code}m"
  end
end
